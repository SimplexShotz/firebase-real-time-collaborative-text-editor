<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realtime Editor Testing</title>
    <style>

      *::selection, .selected {
        background-color: #0C9DFF50; /* Same as rgb(180, 225, 255) but with an alpha value of 0.31 */
      }
      body {
        display: flex;
        flex-direction: column;
        width: 100vw;
        height: 100vh;
        margin: 0px;
        padding: 0px;
        align-items: center;
        justify-content: center;
      }
      #editor {
        display: inline-block;
        padding: 50px;
        width: 60vw;
        height: 40vh;
        overflow-y: auto;
        box-shadow: 0px 0px 10px rgb(225, 225, 225);
        border-radius: 20px;
        font-size: 1.2rem;
        font-family: Helvetica;
        transition: box-shadow 0.25s;
      }
      #editor:hover {
        box-shadow: 0px 0px 10px rgb(200, 200, 200);
      }
      #editor:focus {
        outline: none;
        box-shadow: 0px 0px 10px rgb(200, 200, 200);
      }

      .buttons {
        display: flex;
        justify-content: center;
        margin-bottom: 20px;
        border-radius: 20px;
        box-shadow: 0px 0px 10px rgb(225, 225, 225);
        padding: 10px 5px;
      }
      .button {
        width: 50px;
        height: 50px;
        line-height: 50px;
        border-radius: 10px;
        box-shadow: 0px 0px 10px rgb(225, 225, 225);
        font-size: 1.5rem;
        font-family: Helvetica;
        transition: box-shadow 0.25s;
        margin: 0px 5px;
        text-align: center;
        transition: box-shadow 0.25s;
      }
      .button:hover {
        cursor: pointer;
        box-shadow: 0px 0px 10px rgb(200, 200, 200);
      }
      .button-active {
        box-shadow: 0px 0px 10px rgb(50, 150, 225);
      }
      .button-active:hover {
        box-shadow: 0px 0px 10px rgb(25, 125, 200);
      }
      .bold {
        font-weight: bold;
      }
      .italic {
        font-style: italic;
      }
      .underline {
        text-decoration: underline;
      }
      .strikethrough {
        text-decoration: line-through;
      }
      .underline.strikethrough {
        text-decoration: underline line-through;
      }
      .link {
        color: rgb(50, 150, 225);
      }

      .link-creator {
        display: flex;
        background-color: rgb(255, 255, 255);
        width: 360px;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0px 0px 10px rgb(225, 225, 225);
        font-size: 1.2rem;
        font-family: Helvetica;
      }
      .link-creator-input {
        white-space: nowrap;
        overflow-x: auto;
        flex: 1;
        margin-right: 10px;
      }
      .link-creator-input:focus {
        outline: none;
      }
      .link-creator-preview, .link-creator-cancel {
        margin-right: 10px;
      }
      .link-creator-preview, .link-creator-cancel, .link-creator-confirm {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }
      .link-creator-preview:hover, .link-creator-cancel:hover, .link-creator-confirm:hover {
        cursor: pointer;
      }

      .users {
        pointer-events: none;
        display: inline-block;
        margin-top: 20px;
        padding: 20px 50px;
        width: 60vw;
        overflow-y: auto;
        box-shadow: 0px 0px 10px rgb(225, 225, 225);
        border-radius: 20px;
        font-size: 1.2rem;
        font-family: Helvetica;
        transition: box-shadow 0.25s;
        text-align: center;
      }

      @keyframes blink {
        to {
          border-left: 2px solid rgba(0, 0, 0, 0);
        }
      }
      @-webkit-keyframes blink {
        to {
          border-left: 2px solid rgba(0, 0, 0, 0);
        }
      }
    </style>
  </head>
  <body>
    <div class="buttons"><div class="button bold" id="bold">B</div><div class="button italic" id="italic">I</div><div class="button underline" id="underline">U</div><div class="button strikethrough" id="strikethrough">S</div><div class="button link" id="link">K</div></div>
    <div id="editor" contenteditable="plaintext-only"></div>
    <div class="users">Active: ... &nbsp&nbsp|&nbsp&nbsp Idle: ...</div>
    <script type="module">

      /*

      Things to make this even better:

        [DONE!!] Send data regarding the key that comes before/after it; this can then be used to error check and correctly position keys when pressed at the exact same time
        [DONE!!] Maximize the conditions met by checking the score if positioned one char to the right, or one char to the left (having the letters on both sides of the char to insert [2/2] is ideal; otherwise, shoot for [1/2]; if [0/0], leave the char where it is)
        [DONE!!] ALSO: periodically (not very often, however) pull the ACTUAl content stored in Firebase(?) perhaps only do this on blur and focus(?) ===> update the text region periodically, assuming that it is not currently being focused (elm !== document.activeElement)

      also to implement:

      [NOTE] pay attention to [NOTE]s!!!

        [NOTE] check for document.activeElement or document.activeElement.id checks; these need to ensure that activeElement is a valid vertex

            - [DONE!!] deleting
                ([DONE!!]including deleting selections of text)
            - [DONE!!] pasting
            - [DONE!!]  selecting text and then typing/pasting/etc. (perhaps handle these events (selecting text + whatever else) separately?)

        [DONE!!] spaces (when typed) are not treated as char 160 on the client's end (e.preventDefault() is needed??) [FIXED BY CHANGING ALL TO SPACES]

        [CANCELED] sync in the background when not focused (ignore changes, basically)
        [DONE!!] periodically check sync(?)
        [DONE!! IMPORTANT] ==> remove old "changes" ( > 10 mins old (?)) [remove them if all users have updated to them; check the lastUpdated timestamp in user data and if all are > timestamp for change, delete it]

        [DONE!!] display cursor positions + selections => USE SPANS!!!
        [DONE!!] update cursors on sync
        [DONE!!] store cursor positions locally + update them whenever something is typed/changes come in (maybe)
        [DONE!!] don't update a user's cursor unless it has changed
        [DONE!!] figure out why sync will randomly go off sometimes??
        [DONE!!] if content is synced too many times within a short time frame, assume that something went wrong and kick the client, reloading the page
        [DONE!!] figure out why the editor doesn't like "ÃŸ"
        [DONE!!] figure out why undoing/redoing certain things (such as typing) only has a FitScore of 4 ??? (should be 5)
        [DONE!!] test new FitScore implementation
        [DONE!!] whenever cursor is changed, update user.changed; then, only update the cursor position if the "user.changed" value has been updated + the other pre-existing if-check is met
        [DONE!!] when typing fast at the same pos as other user's cursor, they desync

        [TODO] handle Chromebook grammar checker???
        [TODO] TEST TEST TEST!!!

        [DONE!!] check styling on syncing

        [DONE!!] status sometimes not pushed to firebase??? (might be bc laptop fell asleep + ondisconnect was called; see if theres a reconnect function or smth??)

        [DONE!!] bold, italics, underlining
        [DONE!!] strikethrough
        [DONE!!] links!! :D
        [DONE!!] implement links themselves
        [DONE!!] send link changes
        [DONE!!] store links in Firebase
        [DONE!!] sync if links are not synced up properly
        [DONE!!] undo/redo links
        [DONE!!] only apply link styling if typing within a link; check the space to the right as well; if typing directly after a link, the styling should not be applied
        [DONE!!] add a button to open links

        [DONE!!] \n sometimes changes to \r (???? might've been bc i was screwing around with cursor stuff... might not be an issue but still test anyway)
        [DONE!! (MIGHT BE FIXED??)] sometimes when one person is typing and the other is typing / deletes, their cursor will jump to the start of the doc which is kinda annoying
        [DONE!!] if text is selected (ctrl + a) and end of selection is end of doc, and someone types something, keep end of selection at end of doc
        [DONE!!] handle ctrl + x
        [DONE!!] disable ctrl + delete
        [DONE!!] implement custom ctrl + delete (replace until previous space with "" [nothing] - note that if character immediately before cursor is a space, that space should be ignored and deleted as well as the rest of the text content, like normal ctrl + delete)
        [DONE!!] enters at bottom of doc don't show up until after syncing (sometimes) + sometimes things show up on the wrong bottom line (oof)
        [DONE!!] pasting in content with line breaks does not work properly (yikes)

        [DONE!!] before and after checking should stop at index -1 (or -2 idk) or at the end of the text content; otherwise, you might get false positives which is not ideal

        [DONE!!] HANDLE dragging + dropping text???
        [DONE!!] HANDLE CTRL + Z (should be disabled if multiple editors at same time; or immediate sync(?) assuming client is up-to-date)

        [NOTE] TO TEST: try out multiple docs!! the code should be setup for it already, just need to change depending on what div is focused :)

        [DONE!!] replacing formatted text should copy that text's formatting (first char? idk check what docs does)
        [DONE!!] clicking "bold" or "italic" or "underline" should store those values in some variable + apply styles when key is pressed; wipe if arrow key or mouse is clicked
        [DONE!!] ctrl + b should bold, ctrl + i should italic, etc.
        [DONE!!] send style updates to firebase
        [DONE!!] store styling in firebase somewhere

        [DONE!!] send undo as a change, rather than the actual event itself LOL [I THINK I FIXED THIS TOO LMAOOOOOOO; test it ig????]
        [DONE!!] moving text around still doesn't work (insertFromDrop) [I THINK I FIXED IT??? TEST THIS AND ALSO TEST WHEN EVERYONE IS ABLE TO MOVE STUFF AROUND]
        [DONE!!] Get spell corrections working!
        [DONE!!] Deny emojis

        [DONE!!] handle errors when not focused on anything and a change is sent
      */

      // Import Firebase modules:
      import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.6/firebase-app.js";
      import { getDatabase, set, get, ref, query, onValue, child, push, remove, onDisconnect } from "https://www.gstatic.com/firebasejs/9.6.6/firebase-database.js";

      // Firebase configuration:
      const firebaseConfig = {
        apiKey: "AIzaSyDChSvCEHSlLxpl-oKr21_kjT3Z_1f-2Nw",
        authDomain: "realtime-editor-testing.firebaseapp.com",
        projectId: "realtime-editor-testing",
        storageBucket: "realtime-editor-testing.appspot.com",
        messagingSenderId: "905100052469",
        appId: "1:905100052469:web:cfaf1072946694eea342bc"
      };

      // Initialize Firebase
      const app = initializeApp(firebaseConfig);
      const db = getDatabase(app);

      let pending = [];
      let applied = [];
      let uid = "User" + getTime().toString() + Math.floor(Math.random() * Math.pow(10, 5)).toString();
      let lastKeyPress;
      let lastChange;
      let lastUpdated;
      let prevContentUpdated = 0;
      let contentCheck = 0;
      let lastInputTimeStamp = 0;
      let activeVertex = false;
      let stack = {
        undo: [],
        redo: []
      };
      let userCache = {};
      let activeStyles = [];

      let contentCheckDelay = 5;
      let syncCount = 0;

      window.addEventListener("load", async function() {

        // If the client disconnects, clear their user data:
        onDisconnect(ref(db, `users/${uid}`)).remove();

        // Get the stored text for the editor:
        let content = (await getData("vertexes/editor/content", function(err) { console.error(err); })) || { vertex: "editor", text: "\n", style: { bold: "", italic: "", underline: "", strikethrough: "" }, uid: "", updated: 0 };
        let userData = (await getData("users", function(err) { console.error(err); })) || {};
        setText(document.getElementById("editor"), content.text + (content.text[content.text.length - 1] !== "\n" ? "\n" : ""), { start: 0, end: 0 }, true);
        setStyle(document.getElementById("editor"), content.style);
        setLinks(document.getElementById("editor"), content.links);
        setCursors(userData);

        // Update the "applied" values:
        let changesObj = await getData("changes", function(err) { console.error(err); });
        for (let i in changesObj) {
          applied.push(i);
        }

        // Set the user data:
        set(ref(db, `users/${uid}`), {
          status: "active",
          vertex: false,
          cursor: false,
          changed: new Date().getTime(),
          updated: new Date().getTime()
        });

        // Get user data:
        onValue(ref(db, "users"), (snapshot) => {
          const userData = snapshot.val();

          if (uid === "_disconnected")
            return;

          // Check for disconnects:
          if (!userData || !userData[uid] || !userData[uid].status) {
            uid = "_disconnected";
            alert("You have been disconnected from the server.\n\nIf this is a recurring issue, there might be something wrong with the editor's content or your internet connection."); // [NOTE]
            location.reload(true);
            return;
          }

          // Remove disconnected user data:
          if (userData["_disconnected"]) {
            remove(ref(db, `users/_disconnected`));
            delete userData["_disconnected"];
          }

          // Update user status:
          let statusData = {
            active: 0,
            idle: 0
          };
          for (let u in userData) {
            statusData[userData[u].status]++;
          }

          document.getElementsByClassName("users")[0].innerHTML = `Active: ${statusData.active} &nbsp&nbsp|&nbsp&nbsp Idle: ${statusData.idle}`;

          // Update cursor positions:
          setCursors(userData);

        });

        // Get new changes coming in:
        onValue(ref(db, "changes"), (snapshot) => {
          const changes = snapshot.val();
          checkForChanges(changes);
        });

        // Check periodically to ensure the clients are all synced properly:
        setInterval(async function() {

          let content = (await getData("vertexes/editor/content", function(err) { console.error(err); })) || { vertex: "editor", text: "\n", style: { bold: "", italic: "", underline: "", strikethrough: "" }, uid: "", updated: 0 };
          sync(document.getElementById("editor"), content);
        }, 250);

        // Check for idle users and remove disconnected users:
        setInterval(async function() {

          let users = (await getData("users", function(err) { console.error(err); })) || { vertex: "editor", text: "\n", style: { bold: "", italic: "", underline: "", strikethrough: "" }, uid: "", updated: 0 };

          // Check if a user is idle or should be kicked:
          for (let u in users) {

            // Set status to idle if no changes have been made for more than 5 minutes:
            if (users[u].status === "active" && getTime() - users[u].changed >= 5 * 60 * 1000) {
              set(ref(db, `users/${u}/status`), "idle");
            }

            // Remove user from the database if they have not recieved an update for more than 10 minutes [NOTE when implementing into real thing, take the last updated time into consideration (for example, a user should only be kicked if they have not recieved an update 5 minutes after the last time the content itself was updated)]:
            if (!users[u].status || getTime() - users[u].updated >= 10 * 60 * 1000) {
              remove(ref(db, `users/${u}`));
            }
          }


        }, 5 * 1000);
      });

      async function sync(el, content) {

        // Ignore if the update is old:
        if (content.updated >= prevContentUpdated) {
          prevContentUpdated = content.updated;
        } else {
          return;
        }

        // Don't sync while applying changes:
        if (getTime() - lastChange <= 1000)
          return;

        // Don't sync while the user is typing:
        if (getTime() - lastKeyPress <= 1000)
          return;

        // Ignore if the update was by the same user:
        if (content.uid === uid)
          return;

        // Check if the client is synced (this checks the text, styling, and links):
        if (content.text !== el.textContent || content.style.bold !== getMeta(el, "bold") || content.style.italic !== getMeta(el, "italic") || content.style.underline !== getMeta(el, "underline") || content.style.strikethrough !== getMeta(el, "strikethrough") || JSON.stringify(content.links) !== JSON.stringify(getMeta(el, "links"))) {

          // Client is not synced; take note of this:
          contentCheck++;

          // If the client is not synced for 5 times in total (~1.25 seconds), sync them:
          if (contentCheck >= contentCheckDelay) {

            console.warn("Sync");

            // Store the caret position to perserve it for later:
            let caretPos = getCaretPosition(document.getElementById("editor"));

            // Grab user data to sync cursors:
            let userData = (await getData("users", function(err) { console.error(err); })) || {};

            // Sync everything:
            document.getElementById("editor").textContent = "";
            setText(el, content.text + (content.text[content.text.length - 1] !== "\n" ? "\n" : ""), { start: 0, end: 0 }, true);
            setStyle(el, content.style);
            setLinks(el, content.links);
            setCursors(userData);
            setCaretPosition(el, caretPos);

            contentCheck = 0;
            syncCount++;

            // Disconnect the user if sync is unable to fix the issue:
            if (syncCount >= 10)
              remove(ref(db, `users/${uid}`));
          }

        // Client is synced; reset the counter:
        } else {
          contentCheck = 0;
          syncCount = 0;
        }
      }

      function setButtons() {

        // Reset active classes:
        while (document.getElementsByClassName("button-active").length > 0)
          document.getElementsByClassName("button-active")[0].classList.remove("button-active");

        // Add the classes back to any active styles:
        for (let i = 0; i < activeStyles.length; i++) {
          document.getElementById(activeStyles[i]).classList.add("button-active");
        }
      }

      function getActiveStyles(el) {

        let caretPos = getCaretPosition(el);

        // Determine what the current active styles should be:
        // No text is selected; get the style of the character before:
        if (caretPos.start === caretPos.end) {
          return (el.childNodes[caretPos.start - 1] && el.childNodes[caretPos.start - 1].classList) ? [...el.childNodes[caretPos.start - 1].classList].filter(cl => (cl.indexOf("cursor") === -1 && cl.indexOf("link") === -1 && cl.indexOf("selected") === -1)) : [];

        // Text is being selected; get the styles that apply to all characters in the selection:
        } else {

          // Get the styles of the first character in the selection:
          let styles = (el.childNodes[caretPos.start] && el.childNodes[caretPos.start].classList) ? [...el.childNodes[caretPos.start].classList].filter(cl => (cl.indexOf("cursor") === -1 && cl.indexOf("link") === -1 && cl.indexOf("selected") === -1)) : [];

          // Remove the style if it doesn't apply to all of the characters in the selection:
          for (let i = caretPos.start + 1; i < caretPos.end; i++) {
            let indexedStyles = (el.childNodes[i] && el.childNodes[i].classList) ? [...el.childNodes[i].classList].filter(cl => (cl.indexOf("cursor") === -1 && cl.indexOf("link") === -1 && cl.indexOf("selected") === -1)) : [];
            styles = styles.filter(cl => indexedStyles.indexOf(cl) !== -1);
          }
          return styles;
        }
      }

      document.getElementById("editor").addEventListener("keydown", async function(e) {

        // Update cursor position in Firebase (after event finishes):
        setTimeout(function() {
          set(ref(db, `users/${uid}/cursor`), getCaretPosition(document.getElementById("editor")));

          // Handle arrow keys and "Ctrl + A":
          if (e.keyCode === 37 || e.keyCode === 38 || e.keyCode === 39 || e.keyCode === 40 || (e.ctrlKey && e.keyCode === 65)) {
            activeStyles = getActiveStyles(document.getElementById("editor"));
            setButtons();

            set(ref(db, `users/${uid}/changed`), getTime());
            set(ref(db, `users/${uid}/status`), "active");
          }
        }, 0);

        // Close the link creator:
        while (document.getElementsByClassName("link-creator").length > 0) {
          document.getElementsByClassName("link-creator")[0].remove();
        }
        clearSelections();

        // Prevent defualt behavior of most keys (alpha-numerical, delete/backspace, undo/redo, styling keys):
        if ((!e.ctrlKey && e.key.length === 1) || (e.keyCode === 8 || e.keyCode === 46 || e.keyCode === 13) || (e.ctrlKey && (e.keyCode === 90 || e.keyCode === 89 || e.keyCode === 66 || e.keyCode === 73 || e.keyCode === 85 || e.keyCode === 83 || e.keyCode === 75)))
          e.preventDefault();

        let caretPos = getCaretPosition(this);
        let key;

        // Handle enter:
        if (e.keyCode === 13)
          key = "\n";

        // Handle backspace / delete:
        if (e.keyCode === 8 && caretPos.end > 0 || e.keyCode === 46 && caretPos.end < this.textContent.length - 1) {

          // No selection:
          if (caretPos.start === caretPos.end) {

            // Handle normal backspace / delete:
            if (!e.ctrlKey) {

              // Update active styles:
              activeStyles = (this.childNodes[caretPos.start - (e.keyCode === 8 ? 1 : 0)] && this.childNodes[caretPos.start - (e.keyCode === 8 ? 1 : 0)].classList) ? [...this.childNodes[caretPos.start - (e.keyCode === 8 ? 1 : 0)].classList].filter(cl => (cl.indexOf("cursor") === -1 && cl.indexOf("link") === -1 && cl.indexOf("selected") === -1)) : [];
              setButtons();

              buffer({
                vertex: "editor",
                action: "delete",
                contentPre: this.textContent[caretPos.start - (e.keyCode === 8 ? 1 : 0)],
                index: {
                  start: caretPos.start - (e.keyCode === 8 ? 1 : 0),
                  end: caretPos.start - (e.keyCode === 8 ? 1 : 0)
                },
                surrounding: {
                  before: this.textContent[caretPos.start - 1 - (e.keyCode === 8 ? 1 : 0)] || false,
                  after: ((caretPos.start + (e.keyCode === 46 ? 1 : 0)) === this.textContent.length - 1 && this.textContent[caretPos.start + (e.keyCode === 46 ? 1 : 0)] === "\n") ? false : (this.textContent[caretPos.start + (e.keyCode === 46 ? 1 : 0)] || false)
                }
              });

              lastKeyPress = getTime();
              attemptToPushChanges(lastKeyPress);

              setText(this, "", { start: caretPos.start - (e.keyCode === 8 ? 1 : 0), end: caretPos.end + (e.keyCode === 46 ? 1 : 0) });

            // Handle Ctrl + Backspace / Delete:
            } else {

              // Determine what index to delete up to:
              let breakCharacters = " `~!@#$%^&*()-_=+[{]}\\|;:'\",<.>/?\n".split("");
              let initialIndex = caretPos.start + (this.textContent[caretPos.start + (e.keyCode === 8 ? -1 : 0)] === " " ? (e.keyCode === 8 ? -2 : 2) : (e.keyCode === 8 ? -1 : 1));
              let i = initialIndex;
              while (i > 0 && i < this.textContent.length - 1 && (breakCharacters.indexOf(this.textContent[i + (e.keyCode === 8 ? -1 : 0)]) === -1 && breakCharacters.indexOf(this.textContent[i + (e.keyCode === 8 ? 0 : -1)]) === -1 || breakCharacters.indexOf(this.textContent[i + (e.keyCode === 8 ? 0 : -1)]) !== -1 && breakCharacters.indexOf(this.textContent[i + (e.keyCode === 8 ? -1 : 0)]) !== -1)) {
                i += (e.keyCode === 8 ? -1 : 1);
              }

              // Update active styles:
              activeStyles = (this.childNodes[i] && this.childNodes[i].classList) ? [...this.childNodes[i].classList].filter(cl => (cl.indexOf("cursor") === -1 && cl.indexOf("link") === -1 && cl.indexOf("selected") === -1)) : [];
              setButtons();

              let start = Math.min(caretPos.start, i);
              let end = Math.max(caretPos.start, i);

              buffer({
                vertex: "editor",
                action: "replace",
                contentPre: this.textContent.substring(start, end),
                content: "",
                index: {
                  start: start,
                  end: end
                },
                surrounding: {
                  before: this.textContent[start - 1] || false,
                  after: (end === this.textContent.length - 1 && this.textContent[end] === "\n") ? false : (this.textContent[end] || false)
                }
              });

              lastKeyPress = getTime();
              attemptToPushChanges(lastKeyPress);

              setText(this, "", { start: start, end: end });

            }
          // Selection:
          } else {

            // Update active styles:
            activeStyles = (this.childNodes[caretPos.start] && this.childNodes[caretPos.start].classList) ? [...this.childNodes[caretPos.start].classList].filter(cl => (cl.indexOf("cursor") === -1 && cl.indexOf("link") === -1 && cl.indexOf("selected") === -1)) : [];
            setButtons();

            buffer({
              vertex: "editor",
              action: "replace",
              contentPre: this.textContent.substring(caretPos.start, caretPos.end),
              content: "",
              index: {
                start: caretPos.start,
                end: caretPos.end
              },
              surrounding: {
                before: this.textContent[caretPos.start - 1] || false,
                after: (caretPos.end === this.textContent.length - 1 && this.textContent[caretPos.end] === "\n") ? false : (this.textContent[caretPos.end] || false)
              }
            });

            lastKeyPress = getTime();
            attemptToPushChanges(lastKeyPress);

            setText(this, "", caretPos);
          }
        }

        // Handle undo/redo:
        // Ctrl + Z (Undo):
        if (e.ctrlKey && !e.shiftKey && e.keyCode === 90 && stack.undo.length > 0) {
          execUndo();
        }

        // Ctrl + Shift + Z or Ctrl + Y (Redo):
        if ((e.ctrlKey && e.shiftKey && e.keyCode === 90 || e.ctrlKey && e.keyCode === 89) && stack.redo.length > 0) {
          execRedo();
        }

        // Handle styling keys and link keys:
        // Ctrl + B (Bold):
        if (e.ctrlKey && !e.shiftKey && e.keyCode === 66) {

          // No text is selected:
          if (caretPos.start === caretPos.end) {
            if (activeStyles.indexOf("bold") === -1) {
              activeStyles.push("bold");
            } else {
              activeStyles.splice(activeStyles.indexOf("bold"), 1);
            }

            setButtons();

          // Text is selected:
          } else {
            applyStyle(document.getElementById("editor"), "bold");
          }
        }

        // Ctrl + I (Italic):
        if (e.ctrlKey && !e.shiftKey && e.keyCode === 73) {

          // No text is selected:
          if (caretPos.start === caretPos.end) {
            if (activeStyles.indexOf("italic") === -1) {
              activeStyles.push("italic");
            } else {
              activeStyles.splice(activeStyles.indexOf("italic"), 1);
            }

            setButtons();

          // Text is selected:
          } else {
            applyStyle(document.getElementById("editor"), "italic");
          }
        }

        // Ctrl + U (Underline):
        if (e.ctrlKey && !e.shiftKey && e.keyCode === 85) {

          // No text is selected:
          if (caretPos.start === caretPos.end) {
            if (activeStyles.indexOf("underline") === -1) {
              activeStyles.push("underline");
            } else {
              activeStyles.splice(activeStyles.indexOf("underline"), 1);
            }

            setButtons();

          // Text is selected:
          } else {
            applyStyle(document.getElementById("editor"), "underline");
          }
        }

        // Ctrl + S (Strikethrough):
        if (e.ctrlKey && !e.shiftKey && e.keyCode === 83) {

          // No text is selected:
          if (caretPos.start === caretPos.end) {
            if (activeStyles.indexOf("strikethrough") === -1) {
              activeStyles.push("strikethrough");
            } else {
              activeStyles.splice(activeStyles.indexOf("strikethrough"), 1);
            }

            setButtons();

          // Text is selected:
          } else {
            applyStyle(document.getElementById("editor"), "strikethrough");
          }
        }

        // Ctrl + K (Link):
        if (e.ctrlKey && !e.shiftKey && e.keyCode === 75) {
          if (caretPos.start !== caretPos.end) {
            createLink(this);
          }
        }

        // If we aren't dealing with a normal key, return now:
        if (e.keyCode !== 13 && (e.ctrlKey || e.altKey || e.key.length > 1))
          return;

        // Handle typing/selecting text and typing:
        if (caretPos.start === caretPos.end) {
          buffer({
            vertex: "editor",
            action: "type",
            content: key || e.key,
            index: {
              start: caretPos.end,
              end: caretPos.end
            },
            surrounding: {
              before: this.textContent[caretPos.end - 1] || false, // The first part of this conditional is to ignore the last "\n" that HTML sometimes autofills (for whatever reason):
              after: (caretPos.end === this.textContent.length - 1 && this.textContent[caretPos.end] === "\n") ? false : (this.textContent[caretPos.end] || false)
            }
          });

          lastKeyPress = getTime();
          attemptToPushChanges(lastKeyPress);
        } else {
          buffer({
            vertex: "editor",
            action: "replace",
            contentPre: this.textContent.substring(caretPos.start, caretPos.end),
            content: key || e.key,
            index: {
              start: caretPos.start,
              end: caretPos.end
            },
            surrounding: {
              before: this.textContent[caretPos.start - 1] || false,
              after: (caretPos.end === this.textContent.length - 1 && this.textContent[caretPos.end] === "\n") ? false : (this.textContent[caretPos.end] || false)
            }
          });

          lastKeyPress = getTime();
          attemptToPushChanges(lastKeyPress);
        }

        setText(this, key || e.key, caretPos);

      });

      document.getElementById("editor").addEventListener("input", function(e) {

        // Update cursor position in Firebase (after event finishes):
        setTimeout(function() {
          set(ref(db, `users/${uid}/cursor`), getCaretPosition(document.getElementById("editor")));
        }, 0);

        // Input was due to a recursive call from insertFromDrop, insertReplacementText, or insertCompositionText and should be ignored:
        if (Math.abs(lastInputTimeStamp - e.timeStamp) <= 1000 || lastInputTimeStamp === Infinity) {
          return;
        }

        // Prevent undo/redo from the context menu (since the custom stack should be used instead):
        if (e.inputType === "historyUndo") {

          // Delete the undo:
          let caretPos = getCaretPosition(this);
          setText(this, "", caretPos);

          // Then alert the user to use "Ctrl + Z" instead:
          alert("Undo from the context menu is not supported.\n\nPlease use \"Ctrl + Z\" instead.");
          return;
        }
        if (e.inputType === "historyRedo") {

          // Undo the redo:
          lastInputTimeStamp = e.timeStamp;
          document.execCommand("undo");

          // Then alert the user to use "Ctrl + Y" instead:
          alert("Redo from the context menu is not supported.\n\nPlease use \"Ctrl + Y\" instead.");
          return;
        }

        // Handle dropped text:
        if (e.inputType === "insertFromDrop") {

          // Perform the insertion (since the dropped text is selected after the insertion):
          let insertCaretPos = getCaretPosition(this);

          buffer({
            vertex: "editor",
            action: "insert",
            content: this.textContent.substring(insertCaretPos.start, insertCaretPos.end),
            index: {
              start: insertCaretPos.start,
              end: insertCaretPos.start
            },
            surrounding: {
              before: this.textContent[insertCaretPos.start - 1] || false,
              after: (insertCaretPos.end === this.textContent.length - 1 && this.textContent[insertCaretPos.end] === "\n") ? false : (this.textContent[insertCaretPos.end] || false)
            }
          });

          setText(this, this.textContent.substring(insertCaretPos.start, insertCaretPos.end), { start: insertCaretPos.start, end: insertCaretPos.start });

          // Then undo the insertion:
          lastInputTimeStamp = e.timeStamp;
          document.execCommand("undo");

          // Then remove where the text originated from (since the original text is selected after the undo):
          let preCaretPos = getCaretPosition(this);

          if (this.textContent.substring(preCaretPos.start, preCaretPos.end).length > 0) {

            buffer({
              vertex: "editor",
              action: "replace",
              contentPre: this.textContent.substring(preCaretPos.start, preCaretPos.end),
              content: "",
              index: {
                start: preCaretPos.start,
                end: preCaretPos.end
              },
              surrounding: {
                before: this.textContent[preCaretPos.start - 1] || false,
                after: (preCaretPos.end === this.textContent.length - 1 && this.textContent[preCaretPos.end] === "\n") ? false : (this.textContent[preCaretPos.end] || false)
              }
            });

            setText(this, "", preCaretPos, true);
          }

          setCaretPosition(this, { start: insertCaretPos.end, end: insertCaretPos.end });

          lastKeyPress = getTime();
          attemptToPushChanges(lastKeyPress);
          return;
        }

        // Handle spelling corrections:
        if (e.inputType === "insertReplacementText") {

          // Start by undoing the spelling correction (to determine the original text):
          lastInputTimeStamp = e.timeStamp;
          document.execCommand("undo");

          // The original text is now selected:
          let preCaretPos = getCaretPosition(this);
          let contentPre = this.textContent.substring(preCaretPos.start, preCaretPos.end);
          let classes = (this.childNodes[preCaretPos.start] && this.childNodes[preCaretPos.start].classList) ? [...this.childNodes[preCaretPos.start].classList].filter(cl => (cl.indexOf("cursor") === -1 && cl.indexOf("link") === -1 && cl.indexOf("selected") === -1)) : [];

          // Then, redo the spelling correction (to determine the new text):
          lastInputTimeStamp = e.timeStamp;
          document.execCommand("redo");

          // The cursor will always be placed after the end of the spelling correction; we know where the spelling correction starts because the spelling correction is always inserted starting at the beginning of the previous selection:
          let postCaretPos = { start: preCaretPos.start, end: getCaretPosition(this).end }; // Note that since the spelling correction is stored in just one element, the end node is really the start + 1
          let content = this.textContent.substring(postCaretPos.start, postCaretPos.end);

          buffer({
            vertex: "editor",
            action: "replace",
            contentPre: contentPre,
            content: content,
            index: {
              start: preCaretPos.start,
              end: preCaretPos.end
            },
            surrounding: {
              before: this.textContent[preCaretPos.start - 1] || false,
              after: (postCaretPos.end === this.textContent.length - 1 && this.textContent[postCaretPos.end] === "\n") ? false : (this.textContent[postCaretPos.end] || false)
            }
          });

          setText(this, content, { start: preCaretPos.start, end: preCaretPos.start + 1 }, false, classes);

          lastKeyPress = getTime();
          attemptToPushChanges(lastKeyPress);
          return;
        }

        // Handle emojis:
        if (e.inputType === "insertCompositionText") {

          lastInputTimeStamp = Infinity;

          // Alert the user that this is not supported:
          alert("Inserting emojis from the context menu is not supported.\n\nPlease copy and paste the emojis in using \"Ctrl + C\" (copy) and \"Ctrl + V\" (paste) instead.");

          // Disconnect the user:
          remove(ref(db, `users/${uid}`));
          return;
        }

      });

      document.getElementById("editor").addEventListener("paste", function(e) {

        // Update cursor position in Firebase (after event finishes):
        setTimeout(function() {
          set(ref(db, `users/${uid}/cursor`), getCaretPosition(document.getElementById("editor")));
        }, 0);

        let caretPos = getCaretPosition(this);

        // Clean pasted text:
        e.preventDefault();
        let textToPaste = (e.clipboardData.getData("text/plain")).split("\r\n").join("\n");

        // Push pasted text:
        if (caretPos.start === caretPos.end) {
          buffer({
            vertex: "editor",
            action: "insert",
            content: textToPaste,
            index: {
              start: caretPos.end,
              end: caretPos.end
            },
            surrounding: {
              before: this.textContent[caretPos.end - 1] || false,
              after: (caretPos.end === this.textContent.length - 1 && this.textContent[caretPos.end] === "\n") ? false : (this.textContent[caretPos.end] || false)
            }
          });

          lastKeyPress = getTime();
          attemptToPushChanges(lastKeyPress);
        } else {
          buffer({
            vertex: "editor",
            action: "replace",
            contentPre: this.textContent.substring(caretPos.start, caretPos.end),
            content: textToPaste,
            index: {
              start: caretPos.start,
              end: caretPos.end
            },
            surrounding: {
              before: this.textContent[caretPos.start - 1] || false,
              after: (caretPos.end === this.textContent.length - 1 && this.textContent[caretPos.end] === "\n") ? false : (this.textContent[caretPos.end] || false)
            }
          });

          lastKeyPress = getTime();
          attemptToPushChanges(lastKeyPress);
        }

        // Insert the text:
        setText(this, textToPaste, caretPos);

      });

      document.getElementById("editor").addEventListener("cut", function(e) {

        // Update cursor position in Firebase (after event finishes):
        setTimeout(function() {
          set(ref(db, `users/${uid}/cursor`), getCaretPosition(document.getElementById("editor")));
        }, 0);

        let caretPos = getCaretPosition(this);

        // Push removed text:
        if (caretPos.start === caretPos.end)
          return;

        buffer({
          vertex: "editor",
          action: "replace",
          contentPre: this.textContent.substring(caretPos.start, caretPos.end),
          content: "",
          index: {
            start: caretPos.start,
            end: caretPos.end
          },
          surrounding: {
            before: this.textContent[caretPos.start - 1] || false,
            after: (caretPos.end === this.textContent.length - 1 && this.textContent[caretPos.end] === "\n") ? false : (this.textContent[caretPos.end] || false)
          }
        });

        lastKeyPress = getTime();
        attemptToPushChanges(lastKeyPress);

      });

      document.getElementById("editor").addEventListener("focus", function(e) {

        // Set this to be the active vertex:
        activeVertex = "editor";
        setTimeout(function() {
          set(ref(db, `users/${uid}/cursor`), getCaretPosition(this));
          set(ref(db, `users/${uid}/vertex`), "editor");
          set(ref(db, `users/${uid}/changed`), getTime());
          set(ref(db, `users/${uid}/status`), "active");
        }, 0);

      });

      document.getElementById("editor").addEventListener("blur", function(e) {

        // Remove this from being the active vertex:
        setTimeout(function() {
          if (!document.activeElement.classList.contains("link-creator-element")) {
            activeVertex = false;
            set(ref(db, `users/${uid}/cursor`), false);
            set(ref(db, `users/${uid}/vertex`), false);
            set(ref(db, `users/${uid}/changed`), getTime());
            set(ref(db, `users/${uid}/status`), "active");
          }
        }, 0);

      });

      document.body.addEventListener("mousedown", function(e) {

        // Close the link popup if it is clicked off of:
        if (e.target.id !== "link" && !e.target.classList.contains("link-creator-element")) {
          while (document.getElementsByClassName("link-creator").length > 0) {
            document.getElementsByClassName("link-creator")[0].remove();
          }
          clearSelections();
        }

        let preCaretPos = document.activeElement.id ? getCaretPosition(document.activeElement) : false; // [NOTE] when implementing into actual editor, additional id checks will need to be made (to ensure it is a valid vertex field)
        let preVertex = document.activeElement.id || false; // [NOTE]

        // Check for links and update cursor position in Firebase (after event finishes):
        setTimeout(function() {

          // Ensure that a valid vertex was clicked on:
          if (document.activeElement.id) { // [NOTE] when implementing into actual editor, additional id checks will need to be made (to ensure it is a valid vertex field)

            let caretPos = document.activeElement.id ? getCaretPosition(document.activeElement) : false; // [NOTE] when implementing into actual editor, additional id checks will need to be made (to ensure it is a valid vertex field)

            // Check if the element clicked is a link:
            if (caretPos.start === caretPos.end && document.activeElement.childNodes[caretPos.end].dataset.href) { // [NOTE] when implementing into actual editor, additional id checks will need to be made (to ensure it is a valid vertex field)

              // Find the start and the end of the link, then select it:
              let start, end, spans = document.activeElement.childNodes;
              for (start = caretPos.start; start > 0; start--) {
                if (spans[start - 1].dataset.href !== spans[caretPos.start].dataset.href)
                  break;
              }
              for (end = caretPos.start; end < document.activeElement.textContent.length; end++) {
                if (spans[end].dataset.href !== spans[caretPos.start].dataset.href)
                  break;
              }

              setCaretPosition(document.activeElement, { start: start, end: end });

              // Once this is done, open the link editor:
              createLink(document.activeElement, document.activeElement.childNodes[caretPos.end].dataset.href);
            }

            if (preCaretPos.start !== caretPos.start || preCaretPos.end !== caretPos.end || preVertex !== document.activeElement.id) {
              activeStyles = getActiveStyles(document.activeElement);
              setButtons();
            }

            // Update cursor position in Firebase:
            set(ref(db, `users/${uid}/cursor`), caretPos);
            set(ref(db, `users/${uid}/changed`), getTime());
            set(ref(db, `users/${uid}/status`), "active");
          } else {
            activeStyles = [];
          }
        }, 0);

      });
      let updateCursorThrottled = throttle(function() {
        if (!document.activeElement.id || document.activeElement.classList.contains("link-creator-element"))
          return;

        set(ref(db, `users/${uid}/cursor`), getCaretPosition(document.activeElement));
        set(ref(db, `users/${uid}/changed`), getTime());
        set(ref(db, `users/${uid}/status`), "active");
      }, 100);
      document.body.addEventListener("mousemove", function(e) {

        let preCaretPos = document.activeElement.id ? getCaretPosition(document.activeElement) : false; // [NOTE] when implementing into actual editor, additional id checks will need to be made (to ensure it is a valid vertex field)
        let preVertex = document.activeElement.id || false; // [NOTE]

        // Update cursor position in Firebase (after event finishes):
        setTimeout(function() {

          // Ensure that a valid vertex was clicked on:
          if (e.buttons === 1 && document.activeElement.id && !document.activeElement.classList.contains("link-creator-element")) { // [NOTE] when implementing into actual editor, additional id checks will need to be made (to ensure it is a valid vertex field)

            let caretPos = document.activeElement.id ? getCaretPosition(document.activeElement) : false; // [NOTE]

            // Update active styles:
            if (preCaretPos.start !== caretPos.start || preCaretPos.end !== caretPos.end || preVertex !== document.activeElement.id) {
              activeStyles = getActiveStyles(document.activeElement);
              setButtons();
            }

            // Update cursor position (throttled so it doesn't send too many updates to Firebase at once):
            updateCursorThrottled();
          }
        }, 0);

      });
      document.body.addEventListener("mouseup", function() {

        let preCaretPos = document.activeElement.id ? getCaretPosition(document.activeElement) : false; // [NOTE] when implementing into actual editor, additional id checks will need to be made (to ensure it is a valid vertex field)
        let preVertex = document.activeElement.id || false; // [NOTE]

        // Update cursor position in Firebase (after event finishes):
        setTimeout(function() {

          // Ensure that a valid vertex was clicked on:
          if (document.activeElement.id && !document.activeElement.classList.contains("link-creator-element")) { // [NOTE] when implementing into actual editor, additional id checks will need to be made (to ensure it is a valid vertex field)

            let caretPos = document.activeElement.id ? getCaretPosition(document.activeElement) : false; // [NOTE]

            if (preCaretPos.start !== caretPos.start || preCaretPos.end !== caretPos.end || preVertex !== document.activeElement.id) {
              activeStyles = getActiveStyles(document.activeElement);
              setButtons();
            }

            set(ref(db, `users/${uid}/cursor`), getCaretPosition(document.activeElement));
            set(ref(db, `users/${uid}/changed`), getTime());
            set(ref(db, `users/${uid}/status`), "active");
          }
        }, 0);

      });

      function setText(el, text, pos, ignoreCursor, classes, href) {

        // There was a text selection that is being overridden; remove the text being overridden:
        if (pos.start !== pos.end) {

          // Use the classes (for styling) and href of the first element if text is being overridden:
          classes = classes ? classes : (el.childNodes[pos.start] && el.childNodes[pos.start].classList) ? [...el.childNodes[pos.start].classList].filter(cl => (cl.indexOf("cursor") === -1 && cl.indexOf("link") === -1 && cl.indexOf("selected") === -1)) : [];
          href = el.childNodes[pos.start] ? (el.childNodes[pos.start].dataset ? ((pos.start >= 0 && el.childNodes[pos.start].dataset.href !== undefined) ? ` data-href="${el.childNodes[pos.start].dataset.href}"` : "") : "" /* < Element is a text DOM element */) : "";

          // Remove the text being overridden:
          for (let i = pos.end - 1; i >= pos.start; i--) {
            if (el.childNodes[i])
              el.childNodes[i].remove();
          }
        }

        // If no text is to be inserted, we're done here:
        if (text.length === 0)
          return;

        // If the text to be inserted contains multiple characters, use a recursive call to add them one at a time (in order):
        if (text.length > 1) {
          for (let i = 0; i < text.length; i++) {
            setText(el, text[i], { start: pos.start + i, end: pos.start + i }, true, classes, href);
          }

          if (!ignoreCursor)
            setCaretPosition(el, { start: pos.start + text.length, end: pos.start + text.length });

          return;
        }

        // Only 1 character is to be added; get the classes (for styling) and the href:
        let classList = classes ? classes : activeStyles;
        if (el.childNodes[pos.start - 1] && el.childNodes[pos.start] && el.childNodes[pos.start - 1].classList && el.childNodes[pos.start - 1].classList.contains("link") && el.childNodes[pos.start - 1].dataset.href === el.childNodes[pos.start].dataset.href)
          classList.push("link");

        // Add cursor selection classes if text is being added in the middle of another user's selection:
        if (el.childNodes[pos.start - 1] && el.childNodes[pos.start - 1].classList && el.childNodes[pos.start] && el.childNodes[pos.start].classList) {
          let cursorSelectionsBefore = [...el.childNodes[pos.start - 1].classList].filter(cl => cl.indexOf("cursor-selection") !== -1);
          let cursorSelectionsAfter = [...el.childNodes[pos.start].classList].filter(cl => cl.indexOf("cursor-selection") !== -1);

          for (let i = 0; i < cursorSelectionsBefore.length; i++) {
            if (cursorSelectionsAfter.indexOf(cursorSelectionsBefore[i]) !== -1)
              classList.push(cursorSelectionsBefore[i]);
          }
        }
        let classText = classList.length > 0 ? ` class="${classList.join(" ")}"`: "";

        let hrefData = href ? href : (el.childNodes[pos.start - 1] && el.childNodes[pos.start] ? ((pos.start - 1 >= 0 && el.childNodes[pos.start - 1].dataset.href !== undefined && el.childNodes[pos.start - 1].dataset.href === el.childNodes[pos.start].dataset.href) ? ` data-href="${el.childNodes[pos.start - 1].dataset.href}"` : "") : "");

        // Append the element to the editor:
        let span = document.createElement("div");
        span.innerHTML = `<span${classText}${hrefData}>${text}</span>`;
        if (pos === el.textContent.length) {
          el.appendChild(span.childNodes[0]);
        } else {
          el.insertBefore(span.childNodes[0], el.childNodes[pos.start]);
        }

        // Set the caret position (if requested):
        if (!ignoreCursor)
          setCaretPosition(el, { start: pos.start + 1, end: pos.start + 1 });

      }

      function setCursors(users) {

        // Check if a user has disconnected:
        for (let u in userCache) {

          // This user no longer exists in Firebase; user has disconnected:
          if (!users[u]) {

            // Delete the user from the cache:
            delete userCache[u];

            // Remove the user's cursor:
            while (document.getElementsByClassName(`cursor_${u}`).length > 0)
              document.getElementsByClassName(`cursor_${u}`)[0].classList.remove(`cursor_${u}`);

            while (document.getElementsByClassName(`cursor-selection_${u}`).length > 0)
              document.getElementsByClassName(`cursor-selection_${u}`)[0].classList.remove(`cursor-selection_${u}`);
          }
        }

        // Check if a user has joined:
        for (let u in users) {

          // This user did not previously exist in cache; this is a new user:
          if (!userCache[u]) {

            userCache[u] = users[u];
            userCache[u].newUser = true;

            // Set cursor styles:
            setCSSStyle(`cursor_${u}`, `border-left: 2px solid ${stringToColor(u)}; margin-left: -2px; animation: blink 1.06s steps(2, start) infinite; -webkit-animation: blink 1.06s steps(2, start) infinite;`);
            setCSSStyle(`cursor-selection_${u}`, `background-color: ${stringToColor(u)}50;`);
          }
        }

        for (let u in users) {

          // Skip self:
          if (u === uid)
            continue;

          // Check if the user's cursor has not moved; if so, there is no need to update it:
          let currentCursorPos = users[u].vertex ? [...document.getElementById(users[u].vertex).childNodes].indexOf(document.getElementsByClassName(`cursor_${u}`)[0]) : false;

          // Update the cursor if the user is a new user, they have made a change of some sort (including have moved their cursor), or if the cursor is in the wrong position:
          if (!userCache[u].newUser && JSON.stringify(users[u].changed) === JSON.stringify(userCache[u].changed) && ((!users[u].vertex || !users[u].cursor) || (users[u].cursor.start !== users[u].cursor.end) || (!users[uid] || users[u].updated < lastUpdated || users[u].cursor.start === currentCursorPos))) {
            userCache[u] = users[u];
            continue;
          }

          // Update the user cache:
          userCache[u] = users[u];

          // Clear previous cursor/cursor selection:
          while (document.getElementsByClassName(`cursor_${u}`).length > 0)
            document.getElementsByClassName(`cursor_${u}`)[0].classList.remove(`cursor_${u}`);

          while (document.getElementsByClassName(`cursor-selection_${u}`).length > 0)
            document.getElementsByClassName(`cursor-selection_${u}`)[0].classList.remove(`cursor-selection_${u}`);

          // Don't apply cursors if this user is not currently editing a vertex:
          if (!users[u].vertex || !users[u].cursor)
            continue;

          // Add new cursor/cursor selection:
          let spans = document.getElementById(users[u].vertex).childNodes;

          // User has a cursor but does not have a selection; add cursor:
          if (users[u].cursor.start === users[u].cursor.end) {

            if (spans[users[u].cursor.start])
              spans[users[u].cursor.start].classList.add(`cursor_${u}`);

          // User has a selection; add cursor selection:
          } else {

            for (let i = users[u].cursor.start; i < users[u].cursor.end; i++) {
              if (spans[i])
                spans[i].classList.add(`cursor-selection_${u}`);
            }

          }
        }

      }

      function setCSSStyle(clas, style) {

        let rules = document.styleSheets[0].cssRules;

        // Change the rule if it already exists:
        for (let i = 0; i < rules.length; i++) {
          if (rules[i].selectorText === `.${clas}`) {
            rules[i].style = style;
            return;
          }
        }

        // Insert new rule if it doesn't already exist:
        document.styleSheets[0].insertRule(`.${clas} { ${style} }`, 0);
      }

      // Styling and Link button event handlers:
      document.getElementById("bold").addEventListener("mousedown", function(e) {
        e.preventDefault();

        if (!document.activeElement.id)
          return;

        let caretPos = getCaretPosition(document.activeElement);
        if (caretPos.start === caretPos.end) {
          if (activeStyles.indexOf("bold") === -1) {
            activeStyles.push("bold");
          } else {
            activeStyles.splice(activeStyles.indexOf("bold"), 1);
          }

          setButtons();
        } else {
          applyStyle(document.activeElement, "bold");
        }
      });
      document.getElementById("italic").addEventListener("mousedown", function(e) {
        e.preventDefault();

        if (!document.activeElement.id)
          return;

        let caretPos = getCaretPosition(document.activeElement);
        if (caretPos.start === caretPos.end) {
          if (activeStyles.indexOf("italic") === -1) {
            activeStyles.push("italic");
          } else {
            activeStyles.splice(activeStyles.indexOf("italic"), 1);
          }

          setButtons();
        } else {
          applyStyle(document.activeElement, "italic");
        }
      });
      document.getElementById("underline").addEventListener("mousedown", function(e) {
        e.preventDefault();

        if (!document.activeElement.id)
          return;

        let caretPos = getCaretPosition(document.activeElement);
        if (caretPos.start === caretPos.end) {
          if (activeStyles.indexOf("underline") === -1) {
            activeStyles.push("underline");
          } else {
            activeStyles.splice(activeStyles.indexOf("underline"), 1);
          }

          setButtons();
        } else {
          applyStyle(document.activeElement, "underline");
        }
      });
      document.getElementById("strikethrough").addEventListener("mousedown", function(e) {
        e.preventDefault();

        if (!document.activeElement.id)
          return;

        let caretPos = getCaretPosition(document.activeElement);
        if (caretPos.start === caretPos.end) {
          if (activeStyles.indexOf("strikethrough") === -1) {
            activeStyles.push("strikethrough");
          } else {
            activeStyles.splice(activeStyles.indexOf("strikethrough"), 1);
          }

          setButtons();
        } else {
          applyStyle(document.activeElement, "strikethrough");
        }
      });
      document.getElementById("link").addEventListener("mousedown", function(e) {
        e.preventDefault();

        // Close old link creators:
        while (document.getElementsByClassName("link-creator").length > 0) {
          document.getElementsByClassName("link-creator")[0].remove();
        }
        clearSelections();

        // Can't create a link if no element is selected:
        if (!document.activeElement.id) // [NOTE] update in future for better checks
          return;

        let caretPos = getCaretPosition(document.activeElement);

        // Open a new link creator if there is a selection:
        if (caretPos.start !== caretPos.end)
          createLink(document.getElementById("editor"));
      });

      function setStyle(el, styles) {

        // Override all styles with the passed in "styles":
        for (let style in styles) {
          for (let i = 0; i < styles[style].length; i++) {
            if (styles[style][i] === "X") {
              applyStyle(el, style, { start: i, end: i + 1 }, true);
            }
          }
        }
      }

      function applyStyle(el, style, pos, addStyle) {

        let spans = el.childNodes;
        let localChange = pos ? false : true;

        // Get current caret position:
        if (!pos)
          pos = getCaretPosition(el);

        // Check if style needs to be added or removed:
        if (addStyle === undefined) {
          addStyle = false;

          for (let i = pos.start; i < pos.end; i++) {
            if (!spans[i].classList.contains(style)) {
              addStyle = true;
              break;
            }
          }
        }

        // If no pos is passed in, assume that this was a local change:
        if (localChange) {

          // Update the active styling:
          setTimeout(function() {
            if (document.activeElement.id) { // [NOTE]
              activeStyles = getActiveStyles(document.activeElement);
              setButtons();
            }
          }, 0);

          // Push changes:
          buffer({
            vertex: "editor",
            action: "style",
            contentPre: el.textContent.substring(pos.start, pos.end),
            content: (addStyle ? "" : "-") + style,
            index: {
              start: pos.start,
              end: pos.end
            },
            surrounding: {
              before: el.textContent[pos.start - 1] || false,
              after: (pos.end === el.textContent.length - 1 && el.textContent[pos.end] === "\n") ? false : (el.textContent[pos.end] || false)
            }
          });

          lastKeyPress = getTime();
          attemptToPushChanges(lastKeyPress);
        }

        // Apply style:
        for (let i = pos.start; i < pos.end; i++) {
          if (addStyle && !spans[i].classList.contains(style)) {
            spans[i].classList.add(style);
          } else if (!addStyle) {
            spans[i].classList.remove(style);
          }
        }
      }

      function createLink(el, link) {

        let spans = el.childNodes;
        let caretPos = getCaretPosition(el);

        // Display that the text is still selected:
        for (let i = caretPos.start; i < caretPos.end; i++) {
          spans[i].classList.add("selected");
        }
        setTimeout(function() {
          set(ref(db, `users/${uid}/vertex`), el.id);
          set(ref(db, `users/${uid}/cursor`), caretPos);
        }, 0);

        // Get the position of the selected text on the display:
        let selectionPos = getSelectionPosition(caretPos);

        // Create the div to insert a link:
        let div = document.createElement("div");
        div.innerHTML = `<div class="link-creator link-creator-element" style="position: absolute; left: calc(${selectionPos.x + selectionPos.w / 2}px - 200px); top: calc(${selectionPos.y + selectionPos.h}px + 20px);">
          <div class="link-creator-input link-creator-element" contenteditable="true">
            ${link || ""}
          </div>
          <div class="link-creator-preview link-creator-element">
            <img src="./resources/icons/editor/preview.svg" class="link-creator-element">
          </div>
          <div class="link-creator-cancel link-creator-element">
            <img src="./resources/icons/close.svg" class="link-creator-element">
          </div>
          <div class="link-creator-confirm link-creator-element">
            <img src="./resources/icons/confirm.svg" class="link-creator-element">
          </div>
        </div>`;

        // Display it to the user:
        document.body.appendChild(div.childNodes[0]); // [NOTE] when implementing into the actual editor, make sure that the link creator is fixed to the editor element itself, so it doesn't move if the page is scrolled

        // Focus the input and add event listeners:
        let linkCreator = document.getElementsByClassName("link-creator")[document.getElementsByClassName("link-creator").length - 1];

        if (!link)
          linkCreator.getElementsByClassName("link-creator-input")[0].focus();

        // Clean pasted text:
        linkCreator.addEventListener("paste", function(e) {
          e.preventDefault();
          let textToPaste = e.clipboardData.getData("text/plain");
          document.execCommand("insertHTML", false, textToPaste);
        });

        // Preview button:
        linkCreator.getElementsByClassName("link-creator-preview")[0].addEventListener("click", function() {
          window.open(linkCreator.getElementsByClassName("link-creator-input")[0].textContent.trim(), "_blank");
        });

        // Close button:
        linkCreator.getElementsByClassName("link-creator-cancel")[0].addEventListener("click", function() {
          applyLink(el, el.childNodes[caretPos.start].dataset.href, caretPos, false, true);
          linkCreator.remove();
          clearSelections();
          el.focus();
          setCaretPosition(el, { start: caretPos.end, end: caretPos.end });
        });

        // Confirm button:
        linkCreator.getElementsByClassName("link-creator-confirm")[0].addEventListener("click", function() {
          if (linkCreator.getElementsByClassName("link-creator-input")[0].textContent.trim() !== "")
            applyLink(el, linkCreator.getElementsByClassName("link-creator-input")[0].textContent.trim(), caretPos, true, true);
          linkCreator.remove();
          clearSelections();
          el.focus();
          setCaretPosition(el, { start: caretPos.end, end: caretPos.end });
        });

        // Handle enter:
        linkCreator.getElementsByClassName("link-creator-input")[0].addEventListener("keydown", function(e) {
          if (e.keyCode === 13) {
            e.preventDefault();
            if (linkCreator.getElementsByClassName("link-creator-input")[0].textContent.trim() !== "")
              applyLink(el, linkCreator.getElementsByClassName("link-creator-input")[0].textContent.trim(), caretPos, true, true);
            linkCreator.remove();
            clearSelections();
            el.focus();
            setCaretPosition(el, { start: caretPos.end, end: caretPos.end });
          }
        });
      }

      function clearSelections() {

        // Clear all elements with the "selected" class:
        while (document.getElementsByClassName("selected").length > 0)
          document.getElementsByClassName("selected")[0].classList.remove("selected");
      }

      function setLinks(el, links) {

        // Override all links with the passed in "links":
        for (let i in links) {
          if (links[i]) {
            applyLink(el, links[i], { start: Number(i), end: Number(i) + 1 }, true, false);
          }
        }
      }

      function applyLink(el, link, pos, addLink, localChange) {

        let spans = el.childNodes;

        // Get current caret position:
        if (!pos)
          pos = getCaretPosition(el);

        // If no pos is passed in, assume that this was a local change:
        if (localChange) {

          // Push changes:
          buffer({
            vertex: "editor",
            action: addLink ? "link" : "-link",
            contentPre: el.textContent.substring(pos.start, pos.end),
            content: link || "",
            index: {
              start: pos.start,
              end: pos.end
            },
            surrounding: {
              before: el.textContent[pos.start - 1] || false,
              after: (pos.end === el.textContent.length - 1 && el.textContent[pos.end] === "\n") ? false : (el.textContent[pos.end] || false)
            }
          });

          lastKeyPress = getTime();
          attemptToPushChanges(lastKeyPress);
        }

        // Apply link:
        for (let i = pos.start; i < pos.end; i++) {
          if (addLink) {
            spans[i].classList.add("link");
            spans[i].dataset.href = link;
          } else {
            spans[i].classList.remove("link");
            spans[i].removeAttribute("data-href");
          }
        }
      }

      function undo(c, buf) {

        // Create and return a change that will undo whatever the passed in change changed:
        switch(c.action) {
          case "type":
            return {
              vertex: c.vertex,
              uid: uid,
              timestamp: getTime(),
              action: "delete",
              contentPre: c.content,
              undo: buf,
              index: {
                start: c.index.start,
                end: c.index.end
              },
              surrounding: {
                before: document.getElementById(c.vertex).textContent[c.index.start - 1] || false,
                after: (c.index.start + 1 === document.getElementById(c.vertex).textContent.length - 1 && document.getElementById(c.vertex).textContent[c.index.start + 1] === "\n") ? false : (document.getElementById(c.vertex).textContent[c.index.start + 1] || false)
              }
            };
          break;
          case "delete":
            return {
              vertex: c.vertex,
              uid: uid,
              timestamp: getTime(),
              action: "type",
              content: c.contentPre,
              undo: buf,
              index: {
                start: c.index.start,
                end: c.index.end
              },
              surrounding: {
                before: document.getElementById(c.vertex).textContent[c.index.start - 1] || false, // The first part of this conditional is to ignore the last "\n" that HTML sometimes autofills (for whatever reason):
                after: (c.index.start === document.getElementById(c.vertex).textContent.length - 1 && document.getElementById(c.vertex).textContent[c.index.start] === "\n") ? false : (document.getElementById(c.vertex).textContent[c.index.start] || false)
              }
            };
          break;
          case "insert":
            return {
              vertex: c.vertex,
              uid: uid,
              timestamp: getTime(),
              action: "replace",
              contentPre: c.content,
              content: "",
              undo: buf,
              index: {
                start: c.index.start,
                end: c.index.end + c.content.length
              },
              surrounding: {
                before: document.getElementById(c.vertex).textContent[c.index.start - 1] || false,
                after: (c.index.start + c.content.length === document.getElementById(c.vertex).textContent.length - 1 && document.getElementById(c.vertex).textContent[c.index.start + c.content.length] === "\n") ? false : (document.getElementById(c.vertex).textContent[c.index.start + c.content.length] || false)
              }
            };
          break;
          case "replace":
            return {
              vertex: c.vertex,
              uid: uid,
              timestamp: getTime(),
              action: "replace",
              contentPre: c.content,
              content: c.contentPre,
              undo: buf,
              index: {
                start: c.index.start,
                end: c.index.start + c.content.length
              },
              surrounding: {
                before: document.getElementById(c.vertex).textContent[c.index.start - 1] || false,
                after: (c.index.start + c.content.length === document.getElementById(c.vertex).textContent.length - 1 && document.getElementById(c.vertex).textContent[c.index.start + c.content.length] === "\n") ? false : (document.getElementById(c.vertex).textContent[c.index.start + c.content.length] || false)
              }
            };
          break;
          case "style":
            return {
              vertex: c.vertex,
              uid: uid,
              timestamp: getTime(),
              action: "style",
              contentPre: c.contentPre,
              content: (c.content[0] === "-" ? c.content.substring(1) : ("-" + c.content)),
              undo: buf,
              index: {
                start: c.index.start,
                end: c.index.end
              },
              surrounding: {
                before: document.getElementById(c.vertex).textContent[c.index.start - 1] || false,
                after: (c.index.end === document.getElementById(c.vertex).textContent.length - 1 && document.getElementById(c.vertex).textContent[c.index.end] === "\n") ? false : (document.getElementById(c.vertex).textContent[c.index.end] || false)
              }
            };
          break;
          case "-link":
          case "link":
            return {
              vertex: c.vertex,
              uid: uid,
              timestamp: getTime(),
              action: c.action[0] === "-" ? "link" : "-link",
              contentPre: c.contentPre,
              content: c.content,
              undo: buf,
              index: {
                start: c.index.start,
                end: c.index.end
              },
              surrounding: {
                before: document.getElementById(c.vertex).textContent[c.index.start - 1] || false,
                after: (c.index.end === document.getElementById(c.vertex).textContent.length - 1 && document.getElementById(c.vertex).textContent[c.index.end] === "\n") ? false : (document.getElementById(c.vertex).textContent[c.index.end] || false)
              }
            };
          break;
        }
      }

      function execUndo() {

        // Undo the change:
        buffer(undo(stack.undo[stack.undo.length - 1], true), true);
        applyChange(undo(stack.undo[stack.undo.length - 1]), true);

        // Push the undone change to the redo stack:
        stack.redo.push(stack.undo[stack.undo.length - 1]);

        // Clear the undone change from the undo stack:
        stack.undo.pop();

        // Push changes to Firebase:
        lastKeyPress = getTime();
        attemptToPushChanges(lastKeyPress);
      }

      function redo(c, buf) {

        if (!buf)
          return c;

        // Update the UID, the timestamp, and set the "redo" key to true when sending out redo changes:
        c.uid = uid;
        c.timestamp = getTime();
        c.redo = true;
        return c;
      }

      function execRedo() {

        // Redo the change:
        buffer(redo(stack.redo[stack.redo.length - 1], true), true);
        applyChange(stack.redo[stack.redo.length - 1], true);

        // Push the undone change to the redo stack:
        stack.undo.push(stack.redo[stack.redo.length - 1]);

        // Clear the undone change from the undo stack:
        stack.redo.pop();

        // Push changes to Firebase:
        lastKeyPress = getTime();
        attemptToPushChanges(lastKeyPress);
      }

      async function attemptToPushChanges(t) {

        // Check for changes on the server side:
        let changesObj = await getData("changes", function(err) { console.error(err); });

        // This will check for changes and apply them if found; otherwise, the function will return false:
        if (!checkForChanges(changesObj, t)) {

          // No changes to handle; push pending changes:
          let changedVertexes = [];

          if (document.activeElement.id) // [NOTE] when implementing into actual editor, verify that this is an actual vertex
            changedVertexes.push(document.activeElement.id);

          while (pending.length > 0) {

            if (changedVertexes.indexOf(pending[0].vertex) === -1)
              changedVertexes.push(pending[0].vertex);

            set(push(child(ref(db), "changes")), pending.splice(0, 1)[0]);
          }

          // Update the stored content and the user changed time:
          setTimeout(function() {

            // Ensure that no changes have been made during the 100ms delay:
            if (getTime() - lastChange < 100)
              return;

            for (let i = 0; i < changedVertexes.length; i++) {
              set(ref(db, `vertexes/${changedVertexes[i]}/content`), {
                text: document.getElementById(changedVertexes[i]).textContent + (document.getElementById(changedVertexes[i]).textContent[document.getElementById(changedVertexes[i]).textContent.length - 1] !== "\n" ? "\n" : ""),
                style: {
                  bold: getMeta(document.getElementById(changedVertexes[i]), "bold"),
                  italic: getMeta(document.getElementById(changedVertexes[i]), "italic"),
                  underline: getMeta(document.getElementById(changedVertexes[i]), "underline"),
                  strikethrough: getMeta(document.getElementById(changedVertexes[i]), "strikethrough")
                },
                links: getMeta(document.getElementById(changedVertexes[i]), "links"),
                updated: getTime(),
                uid: uid
              });
            }
          }, 100);
          setTimeout(async function() {
            set(ref(db, `users/${uid}/changed`), getTime());
            set(ref(db, `users/${uid}/status`), "active");
          }, 0);
          setTimeout(async function() {

            // Update the cursor positions:
            let userData = (await getData("users", function(err) { console.error(err); })) || {};
            setCursors(userData);
          }, 250);
        }

      }

      function getMeta(el, type) {
        switch(type) {
          case "bold":
          case "italic":
          case "underline":
          case "strikethrough":
            return [...el.childNodes].map(elm => elm.classList.contains(type) ? "X" : "_").slice(0, -1).join("");
          break;
          case "links":
            let links = [...el.childNodes].map(elm => elm.dataset.href || "").slice(0, -1);
            let newLinks = {};

            for (let i = 0; i < links.length; i++) {
              if (links[i])
                newLinks[i] = links[i]
            }

            return newLinks;
          break;
        }
      }

      function checkForChanges(changesObj, t) {

        // Orgainze the changes:
        let changes = [];
        for (let i in changesObj) {

          // Check if this change has already been applied:
          if (applied.indexOf(i) !== -1)
            continue;

          let changeToPush = copyObj(changesObj[i]);
          changeToPush.key = i;

          // Otherwise, we will apply this change:
          changes.push(changeToPush);
        }

        // No changes to be made; return:
        if (changes.length === 0)
          return false;

        // Otherwise, we have at least one change to handle:
        quicksort(changes, 0, changes.length - 1, "timestamp");

        // Apply changes:
        for (let i = 0; i < changes.length; i++) {
          if (changes[i].uid !== uid) {
            applyChange(changes[i]);
          }
          applied.push(changes[i].key);
        }

        lastChange = getTime();
        lastUpdated = changes[changes.length - 1].timestamp;

        // After changes have been applied, update the last updated timestamp for this user and check to see if the change can be removed from Firebase:
        setTimeout(async function() {
          await set(ref(db, `users/${uid}/updated`), changes[changes.length - 1].timestamp);

          let users = await getData("users", function(err) { console.error(err); });
          let allChanges = await getData("changes", function(err) { console.error(err); });

          // Determine the most recent change for each vertex:
          let lastChanges = {};
          for (let change in allChanges) {
            lastChanges[allChanges[change].vertex] = change;
          }

          // Remove changes if all clients have applied them:
          let allUpdated;
          for (let change in allChanges) {
            allUpdated = true;
            for (let i in users) {
              if (users[i].updated < allChanges[change].timestamp) {
                allUpdated = false;
                break;
              }
            }

            // If all clients have already applied this change, remove it and update the stored content:
            if (allUpdated) {
              remove(ref(db, `changes/${change}`));

              // If this is the last change for the currently active vertex, update the content in Firebase:
              if (change === lastChanges[allChanges[change].vertex] && allChanges[change].vertex === activeVertex) {
                setTimeout(function() {

                  // Ensure that no changes have been made during the 100ms delay:
                  if (getTime() - lastChange < 100)
                    return;

                  // Update the content in Firebase:
                  set(ref(db, `vertexes/${allChanges[change].vertex}/content`), {
                    text: document.getElementById(allChanges[change].vertex).textContent + (document.getElementById(allChanges[change].vertex).textContent[document.getElementById(allChanges[change].vertex).textContent.length - 1] !== "\n" ? "\n" : ""),
                    style: {
                      bold: getMeta(document.getElementById(allChanges[change].vertex), "bold"),
                      italic: getMeta(document.getElementById(allChanges[change].vertex), "italic"),
                      underline: getMeta(document.getElementById(allChanges[change].vertex), "underline"),
                      strikethrough: getMeta(document.getElementById(allChanges[change].vertex), "strikethrough")
                    },
                    links: getMeta(document.getElementById(allChanges[change].vertex), "links"),
                    updated: getTime(),
                    uid: uid
                  });
                }, 100);
              }
            }
          }
        }, 0);

        // If no pending changes have been made since the last keypress, try again:
        if (t && t === lastKeyPress) {
          attemptToPushChanges();
        }

        return true;

      }

      function applyChange(c, isUndoRedo) {

        // Store the caret position and text content of the editor:
        let caretPos = getCaretPosition(c.vertex);
        let t = document.getElementById(c.vertex).textContent;

        // Remove the "\n" that is always present, but not actually able to be edited:
        t = (t[t.length - 1] === "\n") ? (t.substring(0, t.length - 1)) : t;

        // Determine if a change should be applied in the location it was intended for, or if it should be moved somewhere else (as it often needs to be if changes were made between the time the other user sent the change and when this client recieved it):
        // This can be thought of as the "magic function", as it makes the editor MUCH more reliable when multiple people are typing at the same time:
        let transform = getTransform(c, t);

        // Apply the trasnsform:
        c.index.start += transform;
        c.index.end += transform;

        if (!isUndoRedo) {

          // Apply undo/redo to local stack:
          if (c.undo) {
            if (stack.undo.length > 0) {
              stack.redo.push(stack.undo[stack.undo.length - 1]);
              stack.undo.pop();
            }
          } else if (c.redo) {
            if (stack.redo.length > 0) {
              stack.undo.push(stack.redo[stack.redo.length - 1]);
              stack.redo.pop();
            }

          // Otherwise, this change was not an undo/redo itself; add this change to the local stack for future use:
          } else {
            stack.undo.push(c);
            stack.redo = [];
          }
        }

        // Transform the change based on the pending changes:
        for (let i = 0; i < pending.length; i++) {
          // The pending text comes before the index where the text is to be replaced; therefore, move the text to be inserted over:
          if (pending[i].action === "type" && pending[i].index <= c.index.start) {
            c.index.start++;
          }
          if (pending[i].action === "type" && pending[i].index <= c.index.end) {
            c.index.end++;
          }
          if (pending[i].action === "delete" && pending[i].index <= c.index.start) {
            c.index.start--;
          }
          if (pending[i].action === "delete" && pending[i].index <= c.index.end) {
            c.index.end--;
          }
          if (pending[i].action === "insert" && pending[i].index <= c.index.start) {
            c.index.start += pending[i].content.length;
          }
          if (pending[i].action === "insert" && pending[i].index <= c.index.end) {
            c.index.end += pending[i].content.length;
          }
          // Replacing could be implemented here, but it's quite the hassle
        }

        switch(c.action) {
          case "type":

            // Transform the pending text based on this change:
            for (let i = 0; i < pending.length; i++) {
              // The text to be typed comes before the pending text; therefore, move the pending text over:
              if (pending[i].action === "replace") {
                if (c.index.start <= pending[i].index.start) {
                  pending[i].index.start++;
                  pending[i].index.end++;
                }
                continue;
              }
              if (c.index.start < pending[i].index) {
                pending[i].index++;
              }
            }

            // Type the text:
            setText(document.getElementById(c.vertex), c.content, { start: c.index.start, end: c.index.start }, true, c.style);
          break;
          case "delete":

            // Transform the pending text based on this change:
            for (let i = 0; i < pending.length; i++) {
              // The text to be deleted comes before the pending text; therefore, move the pending text over:
              if (pending[i].action === "replace") {
                if (c.index.start <= pending[i].index.start) {
                  pending[i].index.start--;
                  pending[i].index.end--;
                }
                continue;
              }
              if (c.index.start < pending[i].index) {
                pending[i].index--;
              }
            }

            // Delete the text:
            setText(document.getElementById(c.vertex), "", { start: c.index.start, end: c.index.start + 1 }, true, c.style);
          break;
          case "insert":

            // Transform the pending text based on this change:
            for (let i = 0; i < pending.length; i++) {
              // The text to be inserted comes before the pending text; therefore, move the pending text over:
              if (pending[i].action === "replace") {
                if (c.index.start <= pending[i].index.start) {
                  pending[i].index.start += c.content.length;
                  pending[i].index.end += c.content.length;
                }
                continue;
              }
              if (c.index.start < pending[i].index) {
                pending[i].index += c.content.length;
              }
            }

            // Insert the text:
            setText(document.getElementById(c.vertex), c.content, { start: c.index.start, end: c.index.start }, true, c.style);
          break;
          case "replace":

            // Dealing with pending text could be implemented here, but it's a hassle and "getTransform" will usually handle it on the other clients anyway

            // Replace the text:
            setText(document.getElementById(c.vertex), c.content, { start: c.index.start, end: c.index.end }, true, c.style);
          break;
          case "style":

            // Style the text:
            let addStyle = c.content[0] === "-" ? false : true;
            let style = addStyle ? c.content : c.content.substring(1);
            applyStyle(document.getElementById(c.vertex), style, { start: c.index.start, end: c.index.end }, addStyle);
          break;
          case "-link":
          case "link":

            // Link the text:
            let addLink = c.action[0] === "-" ? false : true;
            applyLink(document.getElementById(c.vertex), c.content, { start: c.index.start, end: c.index.end }, addLink, false);
          break;
        }

        // Update cursor position in Firebase and get active styles (after event finishes):
        setTimeout(function() {

          if (document.activeElement.id) { // [NOTE]
            activeStyles = getActiveStyles(document.activeElement);
            setButtons();
          }

          if (!document.activeElement.classList.contains("link-creator-element"))
            set(ref(db, `users/${uid}/cursor`), getCaretPosition(document.getElementById(c.vertex)));
        }, 0);
      }

      function getTransform(c, t) {

        // Setup weights:
        let weights = { before: 1, at: c.contentPre !== undefined ? 3 : 0, after: 1 };

        // Setup the FitScores object:
        let fitScores = {
          before: {
            scores: [],
            max: -1
          },
          at: 0,
          after: {
            scores: [],
            max: -1
          },
          transform: 0
        };

        // Check to see how good of a fit the intended position is:
        fitScores.at = getFitScore(c, t, 0, weights);

        // Check how good of a fit the positions before and after the intended position are:
        let reach = t.length;
        for (let i = 1; i < reach + 1; i++) {
          fitScores.before.scores.push(getFitScore(c, t, -i, weights));
          fitScores.after.scores.push(getFitScore(c, t, i, weights));
        }

        // Determine the ideal scores for moving the text to be inserted before / after:
        fitScores.before.max = Math.max(...fitScores.before.scores);
        fitScores.after.max = Math.max(...fitScores.after.scores);

        // Get the transform (if moving the character achieves a higher score than where it is currently placed):
        if (fitScores.at !== (weights.before + weights.at + weights.after) && (fitScores.before.max > fitScores.at || fitScores.after.max > fitScores.at)) {
          // If it's better to place the character before, get the transform accordingly (note that the second half of this conditional checks which of the two (before or after) have an index closer to where the character was expected to be placed):
          if (fitScores.before.max > fitScores.after.max || fitScores.before.max === fitScores.after.max && fitScores.before.scores.indexOf(fitScores.before.max) < fitScores.after.scores.indexOf(fitScores.after.max))
            fitScores.transform = -fitScores.before.scores.indexOf(fitScores.before.max) - 1; // Subtract 1 since arrays start at 0

          // If it's better to place the character after, get the transform accordingly (same as above for the second half of this conditional; we use a <= here since we will place the character after in the event of a tie-breaker):
          if (fitScores.before.max < fitScores.after.max || fitScores.before.max === fitScores.after.max && fitScores.after.scores.indexOf(fitScores.after.max) <= fitScores.before.scores.indexOf(fitScores.before.max))
            fitScores.transform = fitScores.after.scores.indexOf(fitScores.after.max) + 1; // Add 1 since arrays start at 0
        }

        return fitScores.transform;

      }

      function getFitScore(c, t, offset, weights) {

        // Index is out of range (note that characters can be inserted anywhere from 0 to t.length, hence why this is > t.length and not >= t.length):
        if (c.index.start + offset < 0 || c.index.end + offset > t.length)
          return 0;

        // Calculate the FitScore at the provided index (with offset included):
        let fitScore = {
          // Check the fit before the current offset index:
          before: (checkFit(t, c.index.start + offset - 1, c.surrounding.before) ? weights.before : 0),
          // Check the fit of the content at/between the curent indexes (assuming there is content to check):
          at: (c.contentPre !== undefined && checkFit(t, { start: c.index.start + offset, end: c.index.end + offset }, c.contentPre) ? weights.at : 0),
          // Check the fit after the current offset index (note that we only need to add 1 to the offset if the action is "delete", or something similar):
          after: (checkFit(t, c.index.end + offset + ((c.contentPre !== undefined && c.index.start === c.index.end && c.contentPre !== "") ? 1 : 0), c.surrounding.after) ? weights.after : 0)
        };

        // Return the calculated FitScore:
        return fitScore.before + fitScore.at + fitScore.after;
      }

      function checkFit(t, i, compTo) {

        // Handle cases where only one index is being checked:
        // "i" is the index itself; compare the character at that index to "compTo" (used when checking the before and after surrounding characters):
        if (i.start === undefined)
          return ((i >= 0 && i < t.length) ? t[i] : false) === compTo;

        // The start and end indexes are the same, and "compTo" is empty; this happens when "contentPre" in "replace" is empty; this should always return true:
        if (i.start === i.end && compTo === "")
          return true;

        // The start and end indexes are the same; compare the character at "i.start" to "compTo":
        if (i.start === i.end)
          return ((i.start >= 0 && i.start < t.length) ? t[i.start] : false) === compTo;

        // Handle cases where a group of text (multiple indexes) are being checked:
        // Grab the entire string of characters from "i.start" to "i.end" and compare them to "compTo":
        return t.substring(i.start, i.end) === compTo;
      }

      async function getData(path, err) {

        let data;
        const dbref = ref(db);

        await get(child(dbref, path)).then((snapshot) => {
          if (!snapshot.exists())
            return;

          data = snapshot.val();
        }).catch((error) => {
          err(error);
          console.error(error);
        });

        return data;
      }

      function buffer(c, isUndoRedo) {

        c.uid = uid;
        c.timestamp = getTime();
        c.style = !isUndoRedo ? activeStyles : false;

        pending.push(c);

        // Handle the undo/redo stack:
        if (!isUndoRedo) {
          stack.undo.push(c);
          stack.redo = [];
        }
      }

      function getCaretPosition(el) {

        // If no element is focused, return:
        if (el !== document.activeElement)
          return false;

        // Get the current range:
        let range = window.getSelection().getRangeAt(0);

        // Find the starting position of the range:
        let caretRangeStart = range.cloneRange();
        caretRangeStart.selectNodeContents(el);
        caretRangeStart.setEnd(range.startContainer, range.startOffset);

        // Find the ending position of the range:
        let caretRangeEnd = range.cloneRange();
        caretRangeEnd.selectNodeContents(el);
        caretRangeEnd.setEnd(range.endContainer, range.endOffset);

        // Return the position data:
        return {
          start: caretRangeStart.toString().length,
          end: caretRangeEnd.toString().length
        };

      }

      function setCaretPosition(el, pos) {

        // If the element is not the currently focused element, ignore this attempt to set the caret position:
        if (el !== document.activeElement)
          return;

        // Create a new selection range:
        let range = document.createRange();
        let sel = window.getSelection();

        // Set the start and end of the selection range:
        range.setStart(el.childNodes[Math.min(pos.start, el.textContent.length - 1)], pos.start === el.textContent.length ? 1 : 0);
        range.setEnd(el.childNodes[Math.min(pos.end, el.textContent.length - 1)], pos.end === el.textContent.length ? 1 : 0);

        // Apple the selection range:
        sel.removeAllRanges();
        sel.addRange(range);

      }

      function getSelectionPosition(pos) {

        if (!document.activeElement)
          return;

        // Get the spans:
        let spans = document.activeElement.childNodes;
        let rect;

        // Determine the bounding box of all of the spans:
        let selectionPos = {
          x: {
            min: Infinity,
            max: 0
          },
          y: {
            min: Infinity,
            max: 0
          }
        };

        // Handle if only 1 character is selected:
        if (pos.start === pos.end) {
          return {
            x: rect.left,
            y: rect.top,
            w: 0,
            h: rect.bottom - rect.top
          };
        }

        for (let i = Math.max(pos.start, 0); i < Math.min(pos.end, spans.length); i++) {

          rect = spans[i].getBoundingClientRect();

          selectionPos.x.min = Math.min(selectionPos.x.min, rect.left);
          selectionPos.x.max = Math.max(selectionPos.x.max, rect.right);
          selectionPos.y.min = Math.min(selectionPos.y.min, rect.top);
          selectionPos.y.max = Math.max(selectionPos.y.max, rect.bottom);
        }

        // Return said bounding box:
        return {
          x: selectionPos.x.min,
          y: selectionPos.y.min,
          w: selectionPos.x.max - selectionPos.x.min,
          h: selectionPos.y.max - selectionPos.y.min
        };

      }

      function getTime() {
        return Date.now();
      }

      function stringToColor(str) {

        // Start t on 1:
        let t = 1;
        for (let i = 0; i < str.length; i++) {
          // Vary t based on the contents of the string so each string is (mostly) unique:
          t += 1;
          t *= str.charCodeAt(i);
          t %= 16777216;
        }

        // Return the color (pad with 4's if not long enough):

        let hex = `#${t.toString(16).padStart(6, "4")}`;

        // Hex values starting with "D" (char code = 100) or higher are too bright:
        for (let i = 1; i < hex.length; i += 2) {
          if (hex.charCodeAt(i) >= 100) {
            hex = hex.substring(0, i) + String.fromCharCode(hex.charCodeAt(i) - 3) + hex.substring(i + 1);
          }
        }
        return hex;
      }

      function partition(arr, lo, hi, by) {
        let pivot = (by ? arr[hi][by] : arr[hi]);
        let i = lo;
        for (let j = lo; j < hi; j++) {
          if ((by ? arr[j][by] : arr[j]) < pivot) {
            if (i !== j) {
              let t = arr[j];
              arr[j] = arr[i];
              arr[i] = t;
            }
            i++;
          }
        }
        let t = arr[hi];
        arr[hi] = arr[i];
        arr[i] = t;
        return i;
      }
      function quicksort(arr, lo, hi, by) {
        if (lo < hi) {
          let p = partition(arr, lo, hi, by);
          quicksort(arr, lo, p - 1, by);
          quicksort(arr, p + 1, hi, by);
        }
      }

      function copyObj(obj) {
        return JSON.parse(JSON.stringify(obj));
      }

      function throttle(callback, delay) {

        let runCallback = false;
        let wait = false;
        let timeout = () => {
          if (!runCallback) {
            wait = false;
          } else {
            callback();
            runCallback = false;
            setTimeout(timeout, delay);
          }
        };

        return () => {
          if (wait) {
            runCallback = true;
            return;
          }

          callback();
          wait = true;

          setTimeout(timeout, delay);
        };
      }

    </script>
  </body>
</html>
